#!/usr/bin/env python2.7

# A wrapper for screen
#
# usage: screen_wrapper [-h] [--reattach] [--child] [--window WINDOW] [--ask]
#                       [--list] [--complete]
#                       [session]
#
# positional arguments:
#   session               The session to load. Can be identified by name, pid,
#                         name.pid, pid.name or any unique prefix of previous
#                         options. A "!" suffix forces the creation of a new
#                         screen
#
# optional arguments:
#   -h, --help            show this help message and exit
#   --reattach, -r        Reattach session (don't close existing sessions)
#   --child, -c           Create as child process, don't exec
#   --window WINDOW, -p WINDOW
#                         Open to given window
#   --ask, -a             Ask which screen to open even there is only one match
#   --list, -l            List current screens
#   --complete            List completions for current screens
#
# interactive prompt:
#   The screen is chosen in the following order:
#   - Blank lines match the first preset (0).
#   - Valid numbers match presets.
#   - Unique exact name or pid matches.
#   - Unique prefix matches.
#   Otherwise the a new interactive prompt is shown.
#
#   A "*" prefix in the list means the screen is already attached.
#   Append "!" to force creation of a new screen.
#   CTRL-C or CTRL-D will exit without launching screen.
#   "?" will display this help.

from __future__ import print_function

import argparse
import cmd
import collections
import re
import sys
import subprocess

DEFAULT_SESSION_NAME = '_'
LIST_RE = '\t(\d+)\.([^\t]+)\t\((At|De)tached\)'
BLUE = '\033[94m'
NOCOLOR = '\033[0m'

class Screen(object):
    # A screen object with no pid means create a new screen.
    def __init__(self, name, pid = None, attached=False):
        self.name = name
        self.pid = pid
        self.attached = attached

    def __str__(self):
        if self.pid:
            return '%s.%s' % (self.pid, self.name)
        else:
            return self.name

    def pretty(self):
        wrapped_name = '%s%s%s' % (BLUE, self.name, NOCOLOR)
        if self.pid:
            return '%s.%s' % (wrapped_name, self.pid)
        else:
            return wrapped_name

class ScreenPrompt(cmd.Cmd):
    def __init__(self, all_screens, initial_session):
        cmd.Cmd.__init__(self)
        self.response = None
        self.has_default = has_default(all_screens)
        self.screens = all_screens

        if initial_session:
            # only show intro when there is some initial text, otherwise all
            # options would be shown anyway.
            self.intro = self.get_intro()

        self.prompt, self.options = self.generate_next_prompt(initial_session)

        if initial_session:
            # Add initial_session text to the history so that it can be
            # accessed by pressing up.
            import readline
            readline.add_history(initial_session)

    def precmd(self, line):
        # we only care about the first word
        if not line:
            return line
        else:
            return line.split()[0]

    def onecmd(self, line):
        """ Determine if the line matches a unique screen, or keep going """

        # First check if the user wants to stop.
        if line == 'EOF' or line.startswith('#'):
            return True

        if line.startswith('?'):
            self.do_help()
            return False

        # Check if the user chose the default option (blank line).
        if not line:
            self.response = self.options[0]
            return True

        # Check if the user entered a number which matched an option.
        try:
            option = int(line)
            if 0 <= option < len(self.options):
                self.response = self.options[option]
                return True
        except ValueError:
            pass

        # If not, see if the line matches an existing session.
        screen = find_screen_to_load(self.screens, line)
        if screen:
            self.response = screen
            return True

        # No unique match, try again.
        self.prompt, self.options = self.generate_next_prompt(line)
        return False

    def completenames(self, text, *ignored):
        screens = filter_screens(self.screens, text)
        return get_screen_completions(screens, text)

    def do_help(self, *ignored):
        self.stdout.write(self.get_intro())
        self.stdout.write('\n')
        self.stdout.write('The screen is chosen in the following order:\n')
        self.stdout.write('- Blank lines match the first preset (0).\n')
        self.stdout.write('- Valid numbers match presets.\n')
        self.stdout.write('- Unique exact name or pid matches.\n')
        self.stdout.write('- Unique prefix matches.\n')
        self.stdout.write('Otherwise the a new interactive prompt is shown.\n')
        self.stdout.write('\n')
        self.stdout.write('A "*" prefix in the list means the screen is already attached.\n')
        self.stdout.write('Append "!" to force creation of a new screen.\n')
        self.stdout.write('CTRL-C or CTRL-D will exit without launching screen.\n')
        self.stdout.write('"?" will display this help.\n')
        self.stdout.write('\n')

    def get_intro(self):
        """ Get help text (list of all the screens) """
        if self.screens:
            return ('All current screens: \n' +
                    get_screen_list_string(self.screens) +
                    '\n')
        else:
            return 'No current screens\n\n'

    def generate_next_prompt(self, session):
        """ Returns the next prompt text as well as the list of options it offered """
        screens = filter_screens(self.screens, session)
        if not session and not self.has_default:
            # add the default if there is no default session open, make it the first option.
            screens.insert(0, Screen('_'))
        elif not screens:
            # if there are no options at all then creating is the default.
            screens.append(Screen(session))
        lines = ['Preset options (leave empty for default): ']
        for i, screen in enumerate(screens):
            text = '%s %s: %s' %('*' if screen.attached else ' ', i, screen.pretty())
            if screen.pid is None:
                text += ' (create)'
            if i == 0:
                text += ' [default]'
            lines.append(text)
        lines.append('Type ? for help')
        lines.append('> ')
        return '\n'.join(lines), screens

    def get_user_response(self):
        """ Ask the user which screen they want to open and return the result """
        try:
            self.cmdloop()
        except KeyboardInterrupt:
            return None
        return self.response

def run_screen(screen,
               reattach = False,
               child = False,
               window = None):
    args = ['screen']
    if window is not None:
        args.extend(['-p', window])
    if screen.pid is None:
        # force creation of a new screen
        args.extend(['-S'])
    elif reattach:
        args.extend(['-x', '-S'])
    else:
        args.extend(['-D', '-R'])
    args.append(str(screen))

    import os
    if child:
        subprocess.call(args)
    else:
        os.execvp(args[0], args)

def find_screen_to_load(all_screens, session, default = None):
    if session.endswith('!') and session != '!':
        # exclamation mark forces a new screen to open
        return Screen(session[:-1])
    screens = filter_screens(all_screens, session)
    if not screens:
        return Screen(session or default)
    if len(screens) == 1:
        return screens[0]

    exact_name = []
    exact_pid = []
    for screen in screens:
        if screen.name == session:
            exact_name.append(screen)
        elif screen.pid == session:
            exact_pid.append(screen)

    if len(exact_name) == 1:
        return exact_name[0]
    elif len(exact_pid) == 1:
        return exact_pid[0]

    return None

def filter_screens(screens, session):
    if not session:
        return screens
    return [s for s in screens if
            s.name.startswith(session) or
            (s.pid  + '.' + s.name).startswith(session) or
            (s.name  + '.' + s.pid).startswith(session)]

def get_screen_list():
    process = subprocess.Popen(['screen', '-ls'], stdout=subprocess.PIPE)
    stdout, stderr = process.communicate()

    screens = []
    for line in stdout.split("\n"):
        result = re.match(LIST_RE, line)
        if result:
            screens.append(Screen(
                pid = result.group(1),
                name = result.group(2),
                attached = result.group(3) == 'At',
            ))
    return screens

def has_default(all_screens):
    """ Return true if there are any screens with the default name """
    return any(s.name == DEFAULT_SESSION_NAME for s in all_screens)

def get_screen_list_string(screens, file = sys.stdout):
    lines = []
    for screen in screens:
        lines.append(('* ' if screen.attached else '  ') + screen.pretty())
    return '\n'.join(lines)

def get_screen_completions(screens, session):
    by_name = collections.defaultdict(list)
    for screen in screens:
        by_name[screen.name].append(screen.pid)

    completions = []
    for name, pids in by_name.items():
        if len(pids) == 1 and screen.name.startswith(session):
            completions.append(name)
        else:
            for pid in pids:
                completions.append('%s.%s' %(name, pid))
    return completions

def main():
    parser = argparse.ArgumentParser(description = 'A wrapper for screen')
    parser.add_argument(
        '--reattach', '-r',
        action = 'store_true',
        help = "Reattach session (don't close existing sessions)")
    parser.add_argument(
        '--child', '-c',
        action = 'store_true',
        help = "Create as child process, don't exec")
    parser.add_argument(
        '--window', '-p',
        help = 'Open to given window')
    parser.add_argument(
        '--ask', '-a',
        action = 'store_true',
        help = 'Ask which screen to open even there is only one match')
    parser.add_argument(
        '--list', '-l',
        action = 'store_true',
        help = 'List current screens')
    parser.add_argument(
        '--complete',
        action = 'store_true',
        help = 'List completions for current screens')
    parser.add_argument(
        'session',
        type = str,
        nargs = '?',
        default = '',
        help = 'The session to load. Can be identified by ' +
               'name, pid, name.pid, pid.name or any unique ' +
               'prefix of previous options. A "!" suffix forces ' +
               'the creation of a new screen')

    args = parser.parse_args()

    # get all the screens
    all_screens = get_screen_list()

    # if we just wanted a list of screens (or completions) do that first
    if (args.complete):
        screens = filter_screens(all_screens, args.session)
        print(' '.join(get_screen_completions(screens, args.session)))
        return
    if (args.list):
        screens = filter_screens(all_screens, args.session)
        print(get_screen_list_string(screens))
        return

    # Try to find which screen is being asked for
    screen = None
    if not args.ask:
        screen = find_screen_to_load(all_screens, args.session, DEFAULT_SESSION_NAME)
    if not screen:
        # Multiple possible screens, ask the user!
        screen = ScreenPrompt(all_screens, args.session).get_user_response()
        if not screen:
            print()
            sys.exit(2)

    run_screen(screen,
               child = args.child,
               reattach = args.reattach,
               window = args.window)

if __name__ == '__main__':
    main()
