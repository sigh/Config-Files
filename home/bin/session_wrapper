#!/usr/bin/env python3

# A wrapper for tmux
#
# usage: session_wrapper [-h] [--reattach] [--child] [--window WINDOW] [--ask]
#                       [--list] [--complete] [--binary PATH] [--command COMMAND]
#                       [session]
#
# positional arguments:
#   session               The session to load. Can be identified by name or any
#                         unique prefix. A "!" suffix forces the creation of a
#                         new session
#
# optional arguments:
#   -h, --help            show this help message and exit
#   --reattach, -r        Reattach session (don't close existing sessions)
#   --child, -c           Create as child process, don't exec
#   --ask, -a             Ask which session to open even there is only one match
#   --list, -l            List current sessions
#   --complete            List completions for current sessions
#   --binary              A path to the tmux binary
#   --command             The command to run in the window if this is a new session
#
# interactive prompt:
#   The session is chosen in the following order:
#   - Blank lines match the first preset (0).
#   - Valid numbers match presets.
#   - Unique exact name matches.
#   - Unique prefix matches.
#   Otherwise the a new interactive prompt is shown.
#
#   A "*" prefix in the list means the session is already attached.
#   Append "!" to force creation of a new session.
#   CTRL-C or CTRL-D will exit without launching tmux.
#   "?" will display this help.

import argparse
import cmd
import os
import re
import sys
import subprocess
from typing import List, Optional, Tuple

# ============================================================================
# Constants and Configuration
# ============================================================================

DEFAULT_SESSION_NAME = "_"
BLUE = "\033[94m"
NOCOLOR = "\033[0m"
TMUX_SESSION_LINE_PATTERN = r"([^:]+): .*"

TMUX_BINARY_DEFAULT = "tmux"
FORCE_NEW_SESSION_SUFFIX = "!"
TMUX_ATTACHED_SUFFIX = "(attached)"

# Interactive prompt constants
PROMPT_SYMBOL = "> "
ATTACHED_SESSION_MARKER = "*"
UNATTACHED_SESSION_MARKER = " "
CREATE_SESSION_SUFFIX = " (create)"
DEFAULT_OPTION_SUFFIX = " [default]"


# ============================================================================
# Core Session Management
# ============================================================================


def parse_tmux_session_line(line: str) -> Optional["Session"]:
    """Parse a line from tmux list-sessions output"""
    result = re.match(TMUX_SESSION_LINE_PATTERN, line)
    if result:
        return Session(
            name=result.group(1),
            attached=line.endswith(TMUX_ATTACHED_SUFFIX),
            exists=True,
        )
    return None


def launch_tmux_session(
    session: "Session", binary: str, **options
) -> Tuple[List[str], bool]:
    """Launch or attach to a tmux session"""
    session_name = str(session)
    should_exec = not options.get("child", False)
    base_args = [binary, "-2"]
    tmux_args = []

    if not session.exists:
        # force creation of a new session
        tmux_args.extend(["new-session", "-s"])
    else:
        if options.get("window", None) is not None:
            subprocess.check_call(
                [
                    binary,
                    "select-window",
                    "-t",
                    session_name + ":" + options["window"],
                ]
            )

        tmux_args.append("attach-session")
        if not options.get("reattach", False):
            tmux_args.append("-d")
        tmux_args.append("-t")

    # If we are inside tmux then do things a bit differently
    if options.get("current_tmux_context", None) == "tmux":
        # If the session doesn't exist yet then create it in detached mode.
        if not session.exists:
            # To create a new session the TMUX environment variable must be
            # unset, otherwise tmux gets angry even though we aren't leaving
            # the current sesssion :(
            env = dict(os.environ)
            del env["TMUX"]

            subprocess.check_call(
                [binary, "new-session", "-d", "-s", session_name], env=env
            )

        tmux_args = ["switch-client", "-t"]
        # This is important, if we exec then we destroy the current shell.
        should_exec = False

    tmux_args.append(session_name)

    if not session.exists and options.get("command", None):
        tmux_args.extend([options["command"]])

    return base_args + tmux_args, should_exec


# ============================================================================
# Data Classes
# ============================================================================


class Session:
    def __init__(self, name: str, attached: bool = False, exists: bool = False):
        self.name = name
        self.attached = attached
        self.exists = exists

    def __str__(self) -> str:
        return self.name

    def format_colored(self) -> str:
        return f"{BLUE}{self.name}{NOCOLOR}"


# ============================================================================
# Interactive Session Selection
# ============================================================================


class SessionPrompt(cmd.Cmd):
    def __init__(self, all_sessions: List[Session], initial_session_name: str):
        cmd.Cmd.__init__(self)
        self.response: Optional[Session] = None
        self.has_default = has_default_session(all_sessions)
        self.sessions = all_sessions
        self.prompt = PROMPT_SYMBOL

        self.intro = self.get_session_list_intro() if initial_session_name else ""

        prompt_text, self.options = self.generate_next_prompt(initial_session_name)
        self.intro += prompt_text

        if initial_session_name:
            # Add initial_session_name text to the history so that it can be
            # accessed by pressing up.
            import readline

            readline.add_history(initial_session_name)

    def precmd(self, line):
        # we only care about the first word
        return line.split()[0] if line else line

    def onecmd(self, line):
        """Determine if the line matches a unique session, or keep going"""

        # First check if the user wants to stop.
        if line == "EOF" or line.startswith("#"):
            return True

        if line.startswith("?"):
            self.do_help()
            return False

        # Check if the user chose the default option (blank line).
        if not line:
            self.response = self.options[0]
            return True

        # Check if the user entered a number which matched an option.
        try:
            option = int(line)
            if 0 <= option < len(self.options):
                self.response = self.options[option]
                return True
        except ValueError:
            pass

        # If not, see if the line matches an existing session.
        session = find_session_to_load(self.sessions, line)
        if session:
            self.response = session
            return True

        # No unique match, try again.
        prompt_text, self.options = self.generate_next_prompt(line)
        self.stdout.write(prompt_text + "\n")
        return False

    def completenames(self, text: str, *ignored) -> List[str]:
        sessions = filter_sessions(self.sessions, text)
        return get_session_completions(sessions, text)

    def do_help(self, *ignored) -> None:
        help_text = [
            self.get_session_list_intro(),
            "The session is chosen in the following order:",
            "- Blank lines match the first preset (0).",
            "- Valid numbers match presets.",
            "- Unique exact name matches.",
            "- Unique prefix matches.",
            "Otherwise the a new interactive prompt is shown.",
            "",
            'A "*" prefix in the list means the session is already attached.',
            'Append "!" to force creation of a new session.',
            "CTRL-C or CTRL-D will exit.",
            '"?" will display this help.',
            "",
        ]
        self.stdout.write("\n".join(help_text))

    def get_session_list_intro(self) -> str:
        """Get help text (list of all the sessions)"""
        if self.sessions:
            return f"All current sessions: \n{get_session_list_string(self.sessions)}\n"
        else:
            return "No current sessions\n\n"

    def generate_next_prompt(self, session_name: str) -> Tuple[str, List[Session]]:
        """Returns the next prompt text as well as the list of options it offered"""
        sessions = filter_sessions(self.sessions, session_name)
        if not session_name and not self.has_default:
            sessions.insert(0, Session(DEFAULT_SESSION_NAME))
        elif not sessions:
            sessions.append(Session(session_name))

        lines = ["Preset options (leave empty for default): "]
        for i, session in enumerate(sessions):
            prefix = (
                ATTACHED_SESSION_MARKER
                if session.attached
                else UNATTACHED_SESSION_MARKER
            )
            suffix = CREATE_SESSION_SUFFIX if not session.exists else ""
            default = DEFAULT_OPTION_SUFFIX if i == 0 else ""
            lines.append(f"{prefix} {i}: {session.format_colored()}{suffix}{default}")
        lines.append("Type ? for help")
        return "\n".join(lines), sessions

    def get_user_response(self) -> Optional[Session]:
        """Ask the user which session they want to open and return the result"""
        try:
            self.cmdloop()
        except KeyboardInterrupt:
            return None
        return self.response


# ============================================================================
# Session Execution
# ============================================================================


def run_tmux_session(
    session: Session,
    binary: str,
    reattach: bool = False,
    child: bool = False,
    window: Optional[str] = None,
    current_tmux_context: Optional[str] = None,
    command: Optional[str] = None,
) -> None:
    args, should_exec = launch_tmux_session(
        session,
        binary=binary,
        reattach=reattach,
        window=window,
        child=child,
        current_tmux_context=current_tmux_context,
        command=command,
    )

    if should_exec:
        os.execvp(args[0], args)
    else:
        subprocess.call(args)


# ============================================================================
# Session Discovery and Filtering
# ============================================================================


def find_session_to_load(
    all_sessions: List[Session], session_name: str, default: Optional[str] = None
) -> Optional[Session]:
    # exclamation mark forces a new session to open
    if (
        session_name.endswith(FORCE_NEW_SESSION_SUFFIX)
        and session_name != FORCE_NEW_SESSION_SUFFIX
    ):
        return Session(session_name[:-1])

    # find all matching sessions
    sessions = filter_sessions(all_sessions, session_name)

    # if there are no matching session, suggest making a new one
    if not sessions:
        return Session(session_name or default)

    # if there is one matching session then that's what we want!
    if len(sessions) == 1:
        return sessions[0]

    # Exact name matches
    exact_matches = [s for s in sessions if s.name == session_name]
    if len(exact_matches) == 1:
        return exact_matches[0]

    return None


def filter_sessions(sessions: List[Session], prefix: str) -> List[Session]:
    if not prefix:
        return sessions
    return [s for s in sessions if s.name.startswith(prefix)]


def get_session_list(binary: str) -> List[Session]:
    result = subprocess.run(
        [binary, "list-sessions"], stdout=subprocess.PIPE, stderr=subprocess.PIPE
    )

    return [
        session
        for line in result.stdout.decode("utf-8").split("\n")
        if (session := parse_tmux_session_line(line))
    ]


# ============================================================================
# Utility Functions
# ============================================================================


def has_default_session(all_sessions: List[Session]) -> bool:
    """Return true if there are any sessions with the default name"""
    return any(s.name == DEFAULT_SESSION_NAME for s in all_sessions)


def get_session_list_string(sessions: List[Session]) -> str:
    return "\n".join(
        (ATTACHED_SESSION_MARKER if session.attached else UNATTACHED_SESSION_MARKER)
        + session.format_colored()
        for session in sessions
    )


def get_session_completions(sessions: List[Session], prefix: str) -> List[str]:
    return [s.name for s in sessions if s.name.startswith(prefix)]


def get_current_tmux_context() -> Optional[str]:
    return "tmux" if os.environ.get("TMUX") else None


# ============================================================================
# Main Application
# ============================================================================


def main() -> None:
    parser = argparse.ArgumentParser(description="A wrapper for tmux")
    parser.add_argument(
        "--reattach",
        "-r",
        action="store_true",
        help="Reattach session (don't close existing sessions)",
    )
    parser.add_argument(
        "--child", "-c", action="store_true", help="Create as child process, don't exec"
    )
    parser.add_argument("--window", "-p", help="Open to given window")
    parser.add_argument(
        "--ask",
        "-a",
        action="store_true",
        help="Ask which session to open even there is only one match",
    )
    parser.add_argument(
        "--list", "-l", action="store_true", help="List current sessions"
    )
    parser.add_argument(
        "--complete", action="store_true", help="List completions for current sessions"
    )
    parser.add_argument("--binary", help="The binary for tmux")
    parser.add_argument(
        "--command",
        help="The command to run in the initial window if this is a new session",
    )
    parser.add_argument("session", nargs="?", default="", help="Session name")

    args = parser.parse_args()

    # Start tmux server if needed
    binary = args.binary or TMUX_BINARY_DEFAULT
    subprocess.check_call([binary, "start-server"])

    # get all the sessions
    all_sessions = get_session_list(binary)

    # if we just wanted a list of sessions (or completions) do that first
    if args.complete or args.list:
        sessions = filter_sessions(all_sessions, args.session)
        if args.complete:
            print(" ".join(get_session_completions(sessions, args.session)))
        else:
            print(get_session_list_string(sessions))
        return

    # Try to find which session is being asked for
    session = None
    if not args.ask and args.session:
        session = find_session_to_load(all_sessions, args.session, DEFAULT_SESSION_NAME)
    if not session:
        # Multiple possible sessions, ask the user!
        session = SessionPrompt(all_sessions, args.session).get_user_response()
        if not session:
            print()
            sys.exit(2)

    run_tmux_session(
        session,
        binary=binary,
        child=args.child,
        reattach=args.reattach,
        window=args.window,
        current_tmux_context=get_current_tmux_context(),
        command=args.command,
    )


if __name__ == "__main__":
    main()
